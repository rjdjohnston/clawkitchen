import fs from "node:fs/promises";
import path from "node:path";

import { NextResponse } from "next/server";

import { errorMessage } from "@/lib/errors";
import { runOpenClaw } from "@/lib/openclaw";
import { normalizeId, resolveAgentWorkspace } from "@/lib/swarms";

function escapeShValue(v: string) {
  // Keep it simple: wrap in double-quotes and escape backslash + double-quote + dollar.
  return `"${v.replace(/\\/g, "\\\\").replace(/\"/g, "\\\"").replace(/\$/g, "\\$")}"`;
}

function upsertExportLine(content: string, key: string, value: string) {
  const lines = content.split("\n");
  const assignment = `export ${key}=${escapeShValue(value)}`;

  const re = new RegExp(`^\\s*(export\\s+)?${key}\\s*=`, "i");
  let replaced = false;
  const out = lines.map((line) => {
    if (re.test(line)) {
      replaced = true;
      return assignment;
    }
    return line;
  });

  if (!replaced) {
    // Add near the top, after any shebang / initial comments.
    let insertAt = 0;
    while (insertAt < out.length) {
      const l = out[insertAt];
      if (insertAt === 0 && l.startsWith("#!")) {
        insertAt++;
        continue;
      }
      if (l.trim().startsWith("#") || l.trim() === "") {
        insertAt++;
        continue;
      }
      break;
    }
    out.splice(insertAt, 0, assignment);
  }

  return out.join("\n");
}

export async function POST(req: Request) {
  try {
    const body = (await req.json()) as {
      teamId?: string;
      orchestratorAgentId?: string;
      repoDir?: string;
      worktreeRoot?: string;
      baseRef?: string;
      applyConfig?: boolean;
      makeExecutable?: boolean;
    };

    const teamId = normalizeId("teamId", String(body.teamId ?? ""));
    const orchestratorAgentId = normalizeId("orchestratorAgentId", String(body.orchestratorAgentId ?? ""));
    const repoDir = String(body.repoDir ?? "").trim();
    const worktreeRoot = String(body.worktreeRoot ?? "").trim();
    const baseRef = String(body.baseRef ?? "").trim();

    if (!repoDir) throw new Error("repoDir is required");
    if (!path.isAbsolute(repoDir)) throw new Error("repoDir must be an absolute path");
    if (worktreeRoot && !path.isAbsolute(worktreeRoot)) throw new Error("worktreeRoot must be an absolute path");

    // 1) Scaffold orchestrator agent.
    const scaffoldArgs: string[] = [
      "recipes",
      "scaffold",
      "swarm-orchestrator",
      "--agent-id",
      orchestratorAgentId,
      "--name",
      `${teamId} Swarm Orchestrator`,
    ];
    if (body.applyConfig !== false) scaffoldArgs.push("--apply-config");

    const scaffoldRes = await runOpenClaw(scaffoldArgs);
    if (!scaffoldRes.ok) {
      throw new Error(scaffoldRes.stderr || scaffoldRes.stdout || "Failed to scaffold orchestrator");
    }

    const workspace = await resolveAgentWorkspace(orchestratorAgentId);

    // 2) Write env config.
    const envPath = path.join(workspace, ".clawdbot", "env.sh");
    let env = "";
    try {
      env = await fs.readFile(envPath, "utf8");
    } catch {
      env = "# env.sh (generated by ClawKitchen)\n";
    }

    env = upsertExportLine(env, "SWARM_REPO_DIR", repoDir);
    if (worktreeRoot) env = upsertExportLine(env, "SWARM_WORKTREE_ROOT", worktreeRoot);
    if (baseRef) env = upsertExportLine(env, "SWARM_BASE_REF", baseRef);

    await fs.mkdir(path.dirname(envPath), { recursive: true });
    await fs.writeFile(envPath, env, "utf8");

    // 3) (Optional) chmod +x .clawdbot/*.sh
    if (body.makeExecutable) {
      try {
        const dir = path.join(workspace, ".clawdbot");
        const entries = await fs.readdir(dir);
        const sh = entries.filter((f) => f.endsWith(".sh"));
        for (const f of sh) {
          const p = path.join(dir, f);
          // add +x for user/group/other (standard script perms)
          await fs.chmod(p, 0o750);
        }
      } catch {
        // best-effort
      }
    }

    return NextResponse.json({ ok: true, orchestratorAgentId, workspace });
  } catch (err: unknown) {
    const msg = errorMessage(err);
    const status = /required|match \//i.test(msg) ? 400 : 500;
    return NextResponse.json({ ok: false, error: msg }, { status });
  }
}
