import { NextResponse } from "next/server";
import crypto from "node:crypto";
import { listWorkflowRuns, readWorkflowRun, writeWorkflowRun } from "@/lib/workflows/runs-storage";
import type { WorkflowRunFileV1, WorkflowRunNodeResultV1 } from "@/lib/workflows/runs-types";
import { readWorkflow } from "@/lib/workflows/storage";

function errMessage(err: unknown) {
  return err instanceof Error ? err.message : String(err);
}

function nowIso() {
  return new Date().toISOString();
}

export async function GET(req: Request) {
  const { searchParams } = new URL(req.url);
  const teamId = String(searchParams.get("teamId") ?? "").trim();
  const workflowId = String(searchParams.get("workflowId") ?? "").trim();
  const runId = String(searchParams.get("runId") ?? "").trim();

  if (!teamId) return NextResponse.json({ ok: false, error: "teamId is required" }, { status: 400 });
  if (!workflowId) return NextResponse.json({ ok: false, error: "workflowId is required" }, { status: 400 });

  try {
    if (runId) {
      const r = await readWorkflowRun(teamId, workflowId, runId);
      const { ok: _ok, ...rest } = r;
      return NextResponse.json({ ok: true, ...rest });
    }

    const r = await listWorkflowRuns(teamId, workflowId);
    const { ok: _ok, ...rest } = r;
    return NextResponse.json({ ok: true, ...rest });
  } catch (err: unknown) {
    return NextResponse.json({ ok: false, error: errMessage(err) }, { status: 500 });
  }
}

export async function POST(req: Request) {
  let body: unknown;
  try {
    body = await req.json();
  } catch {
    return NextResponse.json({ ok: false, error: "Invalid JSON" }, { status: 400 });
  }

  const o = body && typeof body === "object" ? (body as Record<string, unknown>) : {};
  const teamId = String(o.teamId ?? "").trim();
  const workflowId = String(o.workflowId ?? "").trim();
  const mode = String(o.mode ?? "").trim();

  if (!teamId) return NextResponse.json({ ok: false, error: "teamId is required" }, { status: 400 });
  if (!workflowId) return NextResponse.json({ ok: false, error: "workflowId is required" }, { status: 400 });

  try {
    const runId = `run-${nowIso().replace(/[:.]/g, "-")}-${crypto.randomBytes(3).toString("hex")}`.toLowerCase();

    const run: WorkflowRunFileV1 =
      mode === "sample"
        ? await (async () => {
            const wf = (await readWorkflow(teamId, workflowId)).workflow;
            const t0 = Date.now();

            const nodeResults: WorkflowRunNodeResultV1[] = wf.nodes.map((n, idx) => {
              const startedAt = new Date(t0 + idx * 350).toISOString();
              const endedAt = new Date(t0 + idx * 350 + 200).toISOString();

              const base: WorkflowRunNodeResultV1 = {
                nodeId: n.id,
                status: "success",
                startedAt,
                endedAt,
              };

              if (n.type === "llm") {
                return {
                  ...base,
                  output: {
                    model: "(sample)",
                    text: `Sample output for ${n.id}`,
                  },
                };
              }

              if (n.type === "tool") {
                const toolVal = n.config && typeof n.config === "object" ? (n.config as Record<string, unknown>).tool : undefined;
                const tool = typeof toolVal === "string" && toolVal.trim() ? toolVal.trim() : "(unknown)";
                return {
                  ...base,
                  output: {
                    tool,
                    result: "(sample tool result)",
                  },
                };
              }

              if (n.type === "human_approval") {
                return {
                  ...base,
                  output: {
                    channel: "(sample)",
                    decision: "approved",
                    approved: true,
                  },
                };
              }

              return base;
            });

            return {
              schema: "clawkitchen.workflow-run.v1",
              id: runId,
              workflowId,
              startedAt: new Date(t0).toISOString(),
              endedAt: new Date(t0 + wf.nodes.length * 350 + 200).toISOString(),
              status: "success",
              summary: "Sample run (generated by ClawKitchen UI)",
              nodes: nodeResults,
            } satisfies WorkflowRunFileV1;
          })()
        : {
            schema: "clawkitchen.workflow-run.v1",
            id: runId,
            workflowId,
            startedAt: nowIso(),
            status: "running",
            summary: "Run created (execution engine not yet wired)",
            nodes: [],
          };

    const r = await writeWorkflowRun(teamId, workflowId, run);
    const { ok: _ok, ...rest } = r;
    return NextResponse.json({ ok: true, runId, ...rest });
  } catch (err: unknown) {
    return NextResponse.json({ ok: false, error: errMessage(err) }, { status: 500 });
  }
}
