import { NextResponse } from "next/server";
import crypto from "node:crypto";
import { listWorkflowRuns, readWorkflowRun, writeWorkflowRun } from "@/lib/workflows/runs-storage";
import type { WorkflowRunFileV1 } from "@/lib/workflows/runs-types";

function errMessage(err: unknown) {
  return err instanceof Error ? err.message : String(err);
}

function nowIso() {
  return new Date().toISOString();
}

export async function GET(req: Request) {
  const { searchParams } = new URL(req.url);
  const teamId = String(searchParams.get("teamId") ?? "").trim();
  const workflowId = String(searchParams.get("workflowId") ?? "").trim();
  const runId = String(searchParams.get("runId") ?? "").trim();

  if (!teamId) return NextResponse.json({ ok: false, error: "teamId is required" }, { status: 400 });
  if (!workflowId) return NextResponse.json({ ok: false, error: "workflowId is required" }, { status: 400 });

  try {
    if (runId) {
      const r = await readWorkflowRun(teamId, workflowId, runId);
      const { ok: _ok, ...rest } = r;
      return NextResponse.json({ ok: true, ...rest });
    }

    const r = await listWorkflowRuns(teamId, workflowId);
    const { ok: _ok, ...rest } = r;
    return NextResponse.json({ ok: true, ...rest });
  } catch (err: unknown) {
    return NextResponse.json({ ok: false, error: errMessage(err) }, { status: 500 });
  }
}

export async function POST(req: Request) {
  let body: unknown;
  try {
    body = await req.json();
  } catch {
    return NextResponse.json({ ok: false, error: "Invalid JSON" }, { status: 400 });
  }

  const o = body && typeof body === "object" ? (body as Record<string, unknown>) : {};
  const teamId = String(o.teamId ?? "").trim();
  const workflowId = String(o.workflowId ?? "").trim();
  const mode = String(o.mode ?? "").trim();

  if (!teamId) return NextResponse.json({ ok: false, error: "teamId is required" }, { status: 400 });
  if (!workflowId) return NextResponse.json({ ok: false, error: "workflowId is required" }, { status: 400 });

  try {
    const runId = `run-${nowIso().replace(/[:.]/g, "-")}-${crypto.randomBytes(3).toString("hex")}`.toLowerCase();

    const run: WorkflowRunFileV1 =
      mode === "sample"
        ? {
            schema: "clawkitchen.workflow-run.v1",
            id: runId,
            workflowId,
            startedAt: nowIso(),
            endedAt: nowIso(),
            status: "success",
            summary: "Sample run (generated by ClawKitchen UI)",
            nodes: [
              { nodeId: "start", status: "success", startedAt: nowIso(), endedAt: nowIso() },
              { nodeId: "research", status: "success", output: { notes: "(sample output)" } },
              { nodeId: "draft_assets", status: "success", output: { x: "draft", instagram: "draft" } },
              { nodeId: "approval", status: "success", output: { approved: true } },
              { nodeId: "end", status: "success" },
            ],
          }
        : {
            schema: "clawkitchen.workflow-run.v1",
            id: runId,
            workflowId,
            startedAt: nowIso(),
            status: "running",
            summary: "Run created (execution engine not yet wired)",
            nodes: [],
          };

    const r = await writeWorkflowRun(teamId, workflowId, run);
    const { ok: _ok, ...rest } = r;
    return NextResponse.json({ ok: true, runId, ...rest });
  } catch (err: unknown) {
    return NextResponse.json({ ok: false, error: errMessage(err) }, { status: 500 });
  }
}
